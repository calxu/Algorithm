# 多段图-向前处理算法
grap_out = {'0': [('1', 9), ('2', 7), ('3', 3), ('4', 2)],
            '1': [('5', 4), ('6', 2), ('7', 1)],
            '2': [('5', 2), ('6', 7)],
            '3': [('7', 11)],
            '4': [('6', 11), ('7', 8)],
            '5': [('8', 6), ('9', 5)],
            '6': [('8', 4), ('9', 3)],
            '7': [('9', 5), ('10', 6)],
            '8': [('11', 4)],
            '9': [('11', 2)],
            '10': [('11', 5)],
            '11': []
            }         # K段图字典形式的表示(出边表)


def f_graph(k, n):
    cost = [100] * n
    d = [0] * (n-1)
    p = [''] * k

    cost[n-1] = 0                   # 将多段图最后一个结点置0
    for i in range(n-2, -1, -1):   # 遍历 10-0 结点的多段图
        e = grap_out[str(i)]        # j所有的出度的边

        for s in e:
            m = s[1] + cost[int(s[0])]       # 设r是一个这样的结点,<i,r>是边,且使 c(i, r)+cost(r) 取最小值
            if m < cost[i]:
                cost[i] = m                  # 使 c(i, r)+cost(r) 取最小值
                d[i] = s[0]                  # 记录当前结点的下一个结点

    p[0] = '0'; p[k-1] = str(n-1)           # 将开始结点 和 结束结点 初始化
    for j in range(1, k):                   # 计算其余k-2个结点
        p[j] = d[int(p[j-1])]                # p[j-1]记录当前结点的下一个最短路径结点

    print(p)                                 # 输出最短路径
    print(cost[0])

if __name__ == '__main__':
    f_graph(5, 12)          # k=5(即5段图),共12个结点
